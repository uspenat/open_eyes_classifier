# -*- coding: utf-8 -*-
"""OpenEyeClassificator

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14AXl39-AVZ53zjFqXcQ5ibU2OUwoNH_p
"""

import numpy as np
from PIL import Image

import torch
import torch.nn as nn
from torchvision import transforms
import torchvision.models as models


class OpenEyesClassificator:
    def __init__(self, ckpt_path):
        self.ckpt_path = ckpt_path
        self.model = models.wide_resnet50_2()
        self.model.fc = nn.Linear(2048, 2)
        self.model.load_state_dict(torch.load(ckpt_path))
        self.transform = transforms.Compose([
                                             transforms.Resize(256),
                                             transforms.CenterCrop(256),
                                             transforms.ToTensor(),
                                             transforms.Normalize(mean=[0.4976, 0.4976, 0.4976],
                                                                  std=[0.1970, 0.1970, 0.1970])
                                             ])
        self.device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
        self.model.eval()

    def predict(self, inplm):
        img = Image.open(inplm)
        img = img.convert('RGB') # 3 channels needed for pretrained wideresnet weights usage 
        img = self.transform(img)
        img = torch.unsqueeze(img, 0)
        img = img.to(self.device)
        
        with torch.no_grad():
            output = self.model(img)
            probs = torch.softmax(output, dim=1)
            is_open_score = probs[:, 1].cpu().numpy()
            preds = torch.argmax(probs, dim=1)

        return is_open_score